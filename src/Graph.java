import java.util.ArrayList;
import java.util.HashMap;
import java.util.Random;

public class Graph implements Visualizable {
    // Play with these values to change the "not totally random" graph generated by void generateRandomGraph().
    private final int linksFromEachPoint = 10, maxDist = 20;
    private int minAxis, maxAxis;
    public final int pointsCount = 200;

    // Holds the list of coordinates for the generated graph points.
    public final Point[] points = new Point[pointsCount];

    // Two representations for the the same graph, to make algorithms implementation easier.
    public final ArrayList<Edge> edgeList = new ArrayList<>();
    public final HashMap<Integer, ArrayList<Pair<Integer, Double>>> adjList = new HashMap<>();

    public Graph(int minAxis, int maxAxis) {
        this.minAxis = minAxis;
        this.maxAxis = maxAxis;
        generateRandomGraph();
    }

    // Name is self-explanatory
    public void generateRandomGraph() {
        edgeList.clear();
        adjList.clear();

        // Generate random points
        Random r = new Random();
        for (int i = 0; i < pointsCount; i++) {
            points[i] = new Point(r.nextInt(maxAxis - minAxis) + minAxis,
                    r.nextInt(maxAxis - minAxis) + minAxis);
        }

        for (int i = 0; i < pointsCount; i++) {
            for (int j = 0; j < linksFromEachPoint; j++) {
                int rand = i;
                while (rand == i || dist(points[i], points[rand]) > maxDist)
                    rand = r.nextInt(pointsCount - 1);

                edgeList.add(new Edge(i, rand, dist(points[i], points[rand])));
                adjList.computeIfAbsent(i, k -> new ArrayList<>());
                adjList.computeIfAbsent(rand, k -> new ArrayList<>());
                adjList.get(i).add(new Pair<>(rand, -dist(points[i], points[rand])));
                adjList.get(rand).add(new Pair<>(i, -dist(points[i], points[rand])));
            }
        }
    }

    // Returns distance between two points
    private double dist(Point a, Point b) {
        return Math.sqrt((b.x() - a.x()) * (b.x() - a.x()) + (b.y() - a.y()) * (b.y() - a.y()));
    }

    @Override
    public void Visualize(Visualizer v, AlgoThread t) {
        // To draw the graph in background.
        StdDraw.enableDoubleBuffering();

        // Generate Random edges, visualize them, then store in data structures.
        StdDraw.setPenRadius(0.001);
        StdDraw.setPenColor(StdDraw.GRAY);

        for (Edge edge : edgeList) {
            Point from = points[edge.from];
            Point to = points[edge.to];
            StdDraw.line(from.x(), from.y(), to.x(), to.y());
        }

        // Visualize generated points
        StdDraw.setPenRadius(0.015);
        StdDraw.setPenColor(StdDraw.BLACK);
        for (Point i : points) {
            StdDraw.point(i.x(), i.y());
        }

        // Show the graph once it's completed.
        StdDraw.disableDoubleBuffering();
    }
}
