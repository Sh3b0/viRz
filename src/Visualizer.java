import java.awt.*;
import java.util.ArrayList;
import java.util.Collections;
import java.util.HashMap;
import java.util.Random;

// Main class for algorithms implementation and visualization.
public class Visualizer {

    // Play with these values to change the "not totally random" graph generated by void generateRandomGraph().
    private static final int pointsCount = 200, linksFromEachPoint = 10, minAxis = 5, maxAxis = 100, maxDist = 20, delay = 50;

    // Holds the list of coordinates for the generated graph points.
    private final Point[] points = new Point[pointsCount];

    // Two representations for the the same graph, to make algorithms implementation easier.
    private final ArrayList<Edge> edgeList = new ArrayList<>();
    private final HashMap<Integer, ArrayList<Pair<Integer, Double>>> adjList = new HashMap<>();

    // For DFS and BFS
    private final boolean[] visited = new boolean[pointsCount];


    // Main method, initializes the application window.
    public static void main(String[] args) {
        StdDraw.setCanvasSize(800, 600);
        StdDraw.setScale(0, minAxis + maxAxis);
        StdDraw.setPenColor(StdDraw.RED);
        StdDraw.textLeft(1, maxAxis + 2, "Please select an algorithm from MenuBar!");
    }

    // Returns distance between two points
    private double dist(Point a, Point b) {
        return Math.sqrt((b.x() - a.x()) * (b.x() - a.x()) + (b.y() - a.y()) * (b.y() - a.y()));
    }

    // Initializes the window for a new algorithm
    private void Init(String txt) {
        StdDraw.clear();
        StdDraw.setPenColor(StdDraw.RED);
        StdDraw.textLeft(2, maxAxis + 2, txt);
        StdDraw.setPenColor(StdDraw.BLACK);
        generateRandomGraph();
        StdDraw.setPenRadius(0.005);
    }

    // Colors a point p, with color c
    private void Visit(Point p, Color c) {
        StdDraw.setPenColor(c);
        StdDraw.setPenRadius(0.015);
        StdDraw.point(p.x(), p.y());
        StdDraw.setPenRadius(0.005);
        StdDraw.setPenColor(StdDraw.BLACK);
    }

    // Displays a "Done" message on the right after the visualization is finished
    private void Done() {
        StdDraw.setPenColor(StdDraw.RED);
        StdDraw.textRight(maxAxis + 2, maxAxis + 2, "DONE!");
        StdDraw.setPenColor(StdDraw.BLACK);
    }

    // Algorithm #1
    public void KruskalMST(AlgoThread t) {
        Init("Implementing Kruskal MST...");

        // Firstly, sort all edges by minimum weight.
        Collections.sort(edgeList);

        // Create a UnionFind DS of size pointsCount + 1, to allow connecting MST vertices and detecting cycles.
        UnionFind uf = new UnionFind(pointsCount + 1);

        // Passing on all edges in order.
        for (Edge e : edgeList) {
            // if the edge can be added without creating a cycle, we add it, mark both ends.
            if (!uf.connected(e.from, e.to)) {
                uf.union(e.from, e.to);
                StdDraw.line(points[e.from].x(), points[e.from].y(), points[e.to].x(), points[e.to].y());
                Visit(new Point(points[e.from].x(), points[e.from].y()), StdDraw.RED);
                Visit(new Point(points[e.to].x(), points[e.to].y()), StdDraw.RED);
                StdDraw.pause(delay);
            }
            if (t.stop) return;
        }
        Done();
    }

    // Algorithm #2
    public void PrimMST(AlgoThread t) {
        Init("Implementing PRIM MST...");

        // Create a Priority Queue, visit first node, add its incidents to the queue.
        MaxPQ<Edge> Q = new MaxPQ<>();
        int visitedCount = 1;
        for (Pair<Integer, Double> i : adjList.get(0))
            Q.push(new Edge(0, i.first, i.second));

        // To mark nodes in MST
        HashMap<Integer, Boolean> in_MST = new HashMap<>();

        // Keep adding the nearest unvisited node to MST, until all nodes are visited or all edges are processed.
        while (Q.size() > 0) {
            Edge e = Q.pop();

            if (in_MST.get(e.to) == null) {
                StdDraw.line(points[e.from].x(), points[e.from].y(), points[e.to].x(), points[e.to].y());
                StdDraw.pause(delay);
                visitedCount++;
            }

            in_MST.put(e.from, true);
            in_MST.put(e.to, true);
            Visit(new Point(points[e.from].x(), points[e.from].y()), StdDraw.RED);
            Visit(new Point(points[e.to].x(), points[e.to].y()), StdDraw.RED);

            if (t.stop) return;

            // To break when the algorithm visits all nodes
            if (visitedCount == pointsCount) {
                Visit(new Point(points[e.to].x(), points[e.to].y()), Color.GREEN);
                break;
            }

            int u = e.to;
            if (adjList.get(u) != null)
                for (Pair<Integer, Double> v : adjList.get(u))
                    if (in_MST.get(v.first) == null)
                        Q.push(new Edge(u, v.first, v.second));

            if (e.from == 0) Visit(new Point(points[e.from].x(), points[e.from].y()), Color.GREEN);
        }
        Done();
    }

    // Algorithm #3
    public void DFS(AlgoThread t) {
        Init("Implementing DFS...");
        for (int i = 0; i < pointsCount; i++) visited[i] = false;
        DFSVisit(0, t);
        Done();
    }

    public void DFSVisit(int s, AlgoThread t) {
        if (t.stop) return;
        visited[s] = true;
        for (Pair<Integer, Double> u : adjList.get(s)) {
            if (!visited[u.first]) {
                StdDraw.line(points[s].x(), points[s].y(), points[u.first].x(), points[u.first].y());
                StdDraw.pause(delay);
                Visit(points[s], StdDraw.RED);
                DFSVisit(u.first, t);
            }
        }
        Visit(points[s], StdDraw.GREEN);
    }

    // Algorithm #4
    public void BFS(AlgoThread t) {
        Init("Implementing BFS...");
        for (int i = 0; i < pointsCount; i++) visited[i] = false;
        Queue<Integer> q = new Queue<>();
        q.push(0);
        visited[0] = true;
        Visit(points[0], StdDraw.GREEN);
        while (!q.empty()) {
            int cur = q.pop();
            for (Pair<Integer, Double> u : adjList.get(cur)) {
                if (!visited[u.first]) {
                    visited[u.first] = true;
                    StdDraw.line(points[cur].x(), points[cur].y(), points[u.first].x(), points[u.first].y());
                    StdDraw.pause(delay);
                    Visit(points[cur], StdDraw.BLUE);
                    Visit(points[u.first], StdDraw.RED);
                    q.push(u.first);
                }
                if (t.stop) return;
            }
            Visit(points[cur], StdDraw.GREEN);
        }

        Done();
    }

    // Name is self-explanatory
    public void generateRandomGraph() {
        edgeList.clear();
        adjList.clear();

        // To draw the graph in background.
        StdDraw.enableDoubleBuffering();

        // Generate random points
        Random r = new Random();
        for (int i = 0; i < pointsCount; i++) {
            points[i] = new Point(r.nextInt(maxAxis - minAxis) + minAxis,
                    r.nextInt(maxAxis - minAxis) + minAxis);
        }

        // Generate Random edges, visualize them, then store in data structures.
        StdDraw.setPenRadius(0.001);
        StdDraw.setPenColor(StdDraw.GRAY);
        for (int i = 0; i < pointsCount; i++) {
            for (int j = 0; j < linksFromEachPoint; j++) {
                int rand = i;
                while (rand == i || dist(points[i], points[rand]) > maxDist)
                    rand = r.nextInt(pointsCount - 1);

                StdDraw.line(points[i].x(), points[i].y(), points[rand].x(), points[rand].y());
                edgeList.add(new Edge(i, rand, dist(points[i], points[rand])));
                adjList.computeIfAbsent(i, k -> new ArrayList<>());
                adjList.computeIfAbsent(rand, k -> new ArrayList<>());
                adjList.get(i).add(new Pair<>(rand, -dist(points[i], points[rand])));
                adjList.get(rand).add(new Pair<>(i, -dist(points[i], points[rand])));
            }
        }

        // Visualize generated points
        StdDraw.setPenRadius(0.015);
        StdDraw.setPenColor(StdDraw.BLACK);
        for (Point i : points) {
            StdDraw.point(i.x(), i.y());
        }

        // Show the graph once it's completed.
        StdDraw.disableDoubleBuffering();
    }
}
